# REFLECTION MODULE 8 

### 1. What are the key difference between unary, server streaming, and bi directional streaming RPC methods, and in what scenarios would each be most suitable
> Unary streaming adalah pola komunikasi antara klien dengan server dimana klien mengirim satu permintaan dan menerima satu respons dari server. Ini digunakan untuk operasi dasar seperti autentikasi, mengambil detail pengguna, atau perhitungan sederhana. Contohnya dipakai dalam program ini adalah pada `MyPaymentService`. Server streaming RPC memungkinkan klien mengirim satu permintaan, tetapi server membalas dengan aliran data yang terdiri dari beberapa respons. Ini sangat berguna dalam situasi seperti pengambilan data dalam jumlah besar secara bertahap, streaming log, atau pengambilan data secara real-time. Contoh dari pola komunikasi ini dipakai dalam `MyTransactionService`. Sementara itu, bidirectional streaming RPC memungkinkan klien dan server untuk saling bertukar pesan secara terus-menerus dan independen dalam satu koneksi yang sama. Ini digunakan dalam aplikasi yang memerlukan komunikasi dua arah secara real-time seperti aplikasi chat, seperti pada `MyChatService`.

### 2. What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?
> Untuk autentikasi, kita perlu memastikan apakah request yang masuk adalah sah, misalnya dengan menggunakan token JWT atau sertifikat TLS. Otorisasi, kita perlu mengecek izin pengguna untuk menentukan apakah ia memiliki hak akses, misalnya menggunakan RBAC. Dan untuk enkripsi data, kita perlu memastikan agar data yang dikirim antara klien dan server tetap aman, kita bisa aktifkan TLS (Transport Layer Security) untuk mengenkripsi seluruh komunikasi. 

### 3. What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?
> Tantangan utama nya adalah mengelola komunikasi dua arah secara bersamaan, di mana klien dan server bisa saling mengirim pesan kapan saja. Ini membutuhkan kontrol alur yang baik agar tidak terjadi kebingungan dalam pengiriman atau penerimaan pesan. Selain itu, kita juga perlu menjaga konsistensi data pengguna, seperti status online atau daftar pesan. Jika beberapa bagian program mengakses atau mengubah data yang sama di waktu yang hampir bersamaan tanpa pengaturan yang tepat, bisa terjadi race condition. Race condition adalah situasi di mana dua proses saling berebut akses ke data yang sama, dan karena urutan eksekusinya tidak terkontrol, hasilnya bisa kacau atau tidak konsisten

### 4. What are the advantages and disadvantages of using the tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services?
> Kelebihan dari ReceiverStream adalah kemampuannya untuk mengonversi (Receiver) dari `tokio::sync::mpsc` menjadi objek `Stream` yang dapat digunakan dalam aliran data asinkron. Hal ini memudahkan kita mengirimkan respons secara bertahap kepada klien tanpa perlu membangun struktur stream secara manual. Namun, kelemahannya adalah potensi overhead yang ditimbulkan oleh saluran asinkron, terutama jika jumlah pesan yang dikirimkan sangat besar atau frekuensinya tinggi. 

### 5. In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?
> Untuk membuat pengembangan dan pemeliharaan layanan gRPC di Rust lebih mudah, kode bisa dipisah ke dalam modul-modul yang berbeda, dan tidak menggabungkannya dalam satu file. Dengan cara ini, kita bisa memanfaatkan trait dan generik untuk membuat antarmuka yang lebih fleksibel dan menangani berbagai tipe data dengan lebih efisien. Hal ini juga membuat kode lebih mudah dibaca dan diuji. Selain itu, dengan struktur folder yang terorganisir dan pengelolaan dependensi yang baik, kita bisa lebih mudah mengelola kompleksitas proyek dan bekerja sama dalam tim, terutama untuk pengembangan jangka panjang.

### 6. In the MyPaymentService implementation, what additional steps might be necessary to handle more complex payment processing logic?
> Untuk menangani logika pemrosesan pembayaran yang lebih kompleks pada MyPaymentService, beberapa langkah tambahan perlu dilakukan. Pertama, perlu memvalidasi input seperti memastikan data pembayaran valid dan jumlah yang dibayar sesuai dengan saldo yang tersedia. Selanjutnya, jika pembayaran melibatkan penyedia layanan external, kode perlu mengintegrasikan API mereka dan menangani respons yang diterima. Keamanan juga harus menjadi prioritas, dengan enkripsi untuk melindungi informasi sensitif seperti kartu kredit dan menggunakan protokol aman. Audit dan logging perlu diterapkan untuk melacak masalah. 

### 7. What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?
> Adopsi gRPC dalam sistem terdistribusi meningkatkan efisiensi komunikasi berkat penggunaan HTTP/2 dan format protokol buffer (protobuf) yang lebih ringan. Ini sangat cocok untuk microservice dan aplikasi real-time. Namun, interoperabilitas dengan platform atau teknologi yang lebih tua bisa menjadi tantangan karena gRPC memerlukan dukungan HTTP/2, dan komunikasi langsung antara server dan browser perlu proxy tambahan. Jadi, meskipun gRPC menawarkan kinerja tinggi, integrasi dengan teknologi lain bisa memerlukan penyesuaian.

### 8. What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?
> HTTP/2 menawarkan keunggulan seperti multiplexing yang memungkinkan pengiriman permintaan dan respons secara paralel, serta kompresi header yang efisien, mengurangi latensi dan overhead dibandingkan HTTP/1.1. Namun, HTTP/2 membutuhkan dukungan dari server dan klien yang lebih baru dan lebih kompleks dalam implementasi. Sementara itu, HTTP/1.1 dengan WebSocket memungkinkan komunikasi dua arah real-time, tetapi tidak seefisien HTTP/2 dalam hal overhead dan multiplexing. Jadi, HTTP/2 lebih efisien, tetapi mungkin tidak cocok untuk sistem yang lebih lama.

### 9. How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?
> REST API menggunakan model request-response, di mana setiap permintaan membutuhkan respons, sehingga kurang efisien untuk komunikasi real-time. Sebaliknya, gRPC dengan streaming dua arah memungkinkan klien dan server saling mengirim data secara terus-menerus, mendukung komunikasi real-time yang lebih responsif dan instan, ideal untuk aplikasi seperti chat atau pemantauan data.

### 10. What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?
> Pendekatan berbasis skema gRPC dengan Protocol Buffers menawarkan tipe data yang terstruktur dan kompresi yang efisien, meningkatkan kinerja dan validasi data yang lebih ketat. Sebaliknya, JSON dalam REST API lebih fleksibel karena tidak memerlukan skema tetap, tetapi bisa lebih lambat dan rentan terhadap kesalahan data karena kurangnya validasi struktural.
